{"ast":null,"code":"// import React, { useEffect, useState } from \"react\";\n\n// // React.memo를 사용하면 컴포넌트가 받는 props가 바뀔 때만 컴포넌트가 렌더링되어 성능 최적화!\n// const CounterA = React.memo(({ count }) => {\n//   useEffect(() => {\n//     console.log({ count });\n//   });\n//   return <div>{count}</div>;\n// });\n\n// // 하지만 props가 객체일 경우 그냥 React.memo를 사용하면 안되고, 비교함수를 사용해야 한다. -> 참조 타입 문제\n// // 1. 컴포넌트를 하나 기본적으로 만들고\n// const CounterB = ({ obj }) => {\n//   useEffect(() => {\n//     console.log(obj.count);\n//   });\n//   return <div>{obj.count}</div>;\n// };\n// // 2. 비교함수를 생성\n// const areEqual = (prevProps, nextProps) => {\n//   return prevProps.obj.count === nextProps.obj.count;\n// };\n// // 3. 새로운 컴포넌트를 만듦(고차 컴포넌트) -> 이를 상위 컴포넌트로 임폴트함.\n// const MemoizedCounterB = React.memo(CounterB, areEqual);\n\n// const OptimizeTest = () => {\n//   const [count, setcount] = useState(1);\n//   const [obj, setobj] = useState({\n//     count: 1,\n//   });\n//   return (\n//     <div style={{ padding: 50 }}>\n//       <div>\n//         <h2>counter A</h2>\n//         <CounterA count={count} />\n//         <button\n//           onClick={() => {\n//             setcount(count);\n//           }}\n//         >\n//           A button\n//         </button>\n//       </div>\n//       <div>\n//         <h2>counter B</h2>\n//         <MemoizedCounterB obj={obj} />\n//         <button\n//           onClick={() => {\n//             setobj({\n//               count: obj.count,\n//             });\n//           }}\n//         >\n//           B button\n//         </button>\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default OptimizeTest;","map":{"version":3,"names":[],"sources":["/Users/ryuhojun/Documents/simple-diary/src/OptimizeTest.js"],"sourcesContent":["// import React, { useEffect, useState } from \"react\";\n\n// // React.memo를 사용하면 컴포넌트가 받는 props가 바뀔 때만 컴포넌트가 렌더링되어 성능 최적화!\n// const CounterA = React.memo(({ count }) => {\n//   useEffect(() => {\n//     console.log({ count });\n//   });\n//   return <div>{count}</div>;\n// });\n\n// // 하지만 props가 객체일 경우 그냥 React.memo를 사용하면 안되고, 비교함수를 사용해야 한다. -> 참조 타입 문제\n// // 1. 컴포넌트를 하나 기본적으로 만들고\n// const CounterB = ({ obj }) => {\n//   useEffect(() => {\n//     console.log(obj.count);\n//   });\n//   return <div>{obj.count}</div>;\n// };\n// // 2. 비교함수를 생성\n// const areEqual = (prevProps, nextProps) => {\n//   return prevProps.obj.count === nextProps.obj.count;\n// };\n// // 3. 새로운 컴포넌트를 만듦(고차 컴포넌트) -> 이를 상위 컴포넌트로 임폴트함.\n// const MemoizedCounterB = React.memo(CounterB, areEqual);\n\n// const OptimizeTest = () => {\n//   const [count, setcount] = useState(1);\n//   const [obj, setobj] = useState({\n//     count: 1,\n//   });\n//   return (\n//     <div style={{ padding: 50 }}>\n//       <div>\n//         <h2>counter A</h2>\n//         <CounterA count={count} />\n//         <button\n//           onClick={() => {\n//             setcount(count);\n//           }}\n//         >\n//           A button\n//         </button>\n//       </div>\n//       <div>\n//         <h2>counter B</h2>\n//         <MemoizedCounterB obj={obj} />\n//         <button\n//           onClick={() => {\n//             setobj({\n//               count: obj.count,\n//             });\n//           }}\n//         >\n//           B button\n//         </button>\n//       </div>\n//     </div>\n//   );\n// };\n\n// export default OptimizeTest;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}